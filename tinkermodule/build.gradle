if (isUserModule.toBoolean()) {
    apply plugin: 'com.android.library'

} else {
    apply plugin: 'com.android.application'

}

android {
    compileSdkVersion 28



    defaultConfig {
        minSdkVersion 19
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    sourceSets {
        main {
            if (isUserModule.toBoolean()) {
                manifest.srcFile 'src/main/release/AndroidManifest.xml'
            } else {
                manifest.srcFile 'src/main/debug/AndroidManifest.xml'
            }
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
    implementation project(':provider')

    implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"
    //可选，用于生成application类
    compileOnly("com.tencent.tinker:tinker-android-anno:$tinker_version")
    //tinker的核心库
    implementation("com.tencent.tinker:tinker-android-lib:$tinker_version")
}

apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'

def backPath =  file("${buildDir}/backApk")

ext{
    tinker_enable = true
    tinkerOldApkPath ="${backPath}/"
    tinkerID = "1.0"
    tinkerApplyMappingPath = "${bakPath}/"
    tinkerApplyResourcePath = "${bakPath}/"
    tinkerBuildFlavorDirectory = "${bakPath}/"
}
def buildTinker(){
        return ext.tinker_enable
}
def getOldApkPath(){
    return ext.getOldApkPath

}

def getApplyMappingPath() {
    return ext.tinkerApplyMappingPath
}

def getApplyResourceMappingPath() {
    return ext.tinkerApplyResourcePath
}

def getTinkerIdValue() {
    return ext.tinkerID
}

def getTinkerBuildFlavorDirectory(){

    return ext.tinkerBuildFlavorDirectory
}
if (buildTinker()){

    //如果启用tinker
    apply plugin: 'com.tencent.tinker.patch'

    tinkerPatch{
        oldApk = getOldApkPath()//指定旧apk的路径
        /**
         * 如果出现以下的情况，并且ignoreWarning为false，我们将中断编译。因为这些情况可能会导致编译出来的patch包带来风险：
         1. minSdkVersion小于14，但是dexMode的值为"raw";
         2. 新编译的安装包出现新增的四大组件(Activity, BroadcastReceiver...)；
         3. 定义在dex.loader用于加载补丁的类不在main dex中;
         4. 定义在dex.loader用于加载补丁的类出现修改；
         5. resources.arsc改变，但没有使用applyResourceMapping编译。
         */
        ignoreWarning = false //是否忽略警告,false为不忽略
        userSign = true //强制patch使用签名
        tinkerEnable = buildTinker()//是否启用tinker
        buildConfig{
            applyMapping = getApplyMappingPath()//指定旧app打包时使用的混淆文件
            applyResourceMapping = getApplyResourceMappingPath()//指定oldapk的资源文件
            tinkerId = getTinkerIdValue()//指定TinkerId
            /**
             * 如果我们有多个dex,编译补丁时可能会由于类的移动导致变更增多。若打开keepDexApply模式，补丁包将根据基准包的类分布来编译。
             */
            keepDexApply = false//一般为false
            /**
             * 以上四个为必须设置的参数
             */

        }
        dex{

            /**
             * 只能是'raw'或者'jar'。
             对于'raw'模式，我们将会保持输入dex的格式。
             对于'jar'模式，我们将会把输入dex重新压缩封装到jar。如果你的minSdkVersion小于14，你必须选择‘jar’模式，而且它更省存储空间，但是验证md5时比'raw'模式耗时。默认我们并不会去校验md5,一般情况下选择jar模式即可。
             */
            dexMode = "jar"//jar row
            pattern = ["classes*.dex","assets/secondary-dex-?.jar"]//tinker要处理的dex文件位于哪些目录
                //第一个是对所有dex文件进行通配,指定class中所有的dex
            loader = []//指定加载的application
        }


    }

}